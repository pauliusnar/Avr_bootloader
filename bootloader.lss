
bootloader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  0000727c  000002f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000027c  00007000  00007000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000011  00000000  00000000  00000314  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000328  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000068  00000000  00000000  00000368  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000c82  00000000  00000000  000003d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000007d4  00000000  00000000  00001052  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000422  00000000  00000000  00001826  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000094  00000000  00000000  00001c48  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000005d9  00000000  00000000  00001cdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000001d8  00000000  00000000  000022b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000068  00000000  00000000  0000248d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	33 c0       	rjmp	.+102    	; 0x7068 <__ctors_end>
    7002:	00 00       	nop
    7004:	44 c0       	rjmp	.+136    	; 0x708e <__bad_interrupt>
    7006:	00 00       	nop
    7008:	42 c0       	rjmp	.+132    	; 0x708e <__bad_interrupt>
    700a:	00 00       	nop
    700c:	40 c0       	rjmp	.+128    	; 0x708e <__bad_interrupt>
    700e:	00 00       	nop
    7010:	3e c0       	rjmp	.+124    	; 0x708e <__bad_interrupt>
    7012:	00 00       	nop
    7014:	3c c0       	rjmp	.+120    	; 0x708e <__bad_interrupt>
    7016:	00 00       	nop
    7018:	3a c0       	rjmp	.+116    	; 0x708e <__bad_interrupt>
    701a:	00 00       	nop
    701c:	38 c0       	rjmp	.+112    	; 0x708e <__bad_interrupt>
    701e:	00 00       	nop
    7020:	36 c0       	rjmp	.+108    	; 0x708e <__bad_interrupt>
    7022:	00 00       	nop
    7024:	34 c0       	rjmp	.+104    	; 0x708e <__bad_interrupt>
    7026:	00 00       	nop
    7028:	32 c0       	rjmp	.+100    	; 0x708e <__bad_interrupt>
    702a:	00 00       	nop
    702c:	30 c0       	rjmp	.+96     	; 0x708e <__bad_interrupt>
    702e:	00 00       	nop
    7030:	2e c0       	rjmp	.+92     	; 0x708e <__bad_interrupt>
    7032:	00 00       	nop
    7034:	2c c0       	rjmp	.+88     	; 0x708e <__bad_interrupt>
    7036:	00 00       	nop
    7038:	2a c0       	rjmp	.+84     	; 0x708e <__bad_interrupt>
    703a:	00 00       	nop
    703c:	28 c0       	rjmp	.+80     	; 0x708e <__bad_interrupt>
    703e:	00 00       	nop
    7040:	26 c0       	rjmp	.+76     	; 0x708e <__bad_interrupt>
    7042:	00 00       	nop
    7044:	24 c0       	rjmp	.+72     	; 0x708e <__bad_interrupt>
    7046:	00 00       	nop
    7048:	22 c0       	rjmp	.+68     	; 0x708e <__bad_interrupt>
    704a:	00 00       	nop
    704c:	20 c0       	rjmp	.+64     	; 0x708e <__bad_interrupt>
    704e:	00 00       	nop
    7050:	1e c0       	rjmp	.+60     	; 0x708e <__bad_interrupt>
    7052:	00 00       	nop
    7054:	1c c0       	rjmp	.+56     	; 0x708e <__bad_interrupt>
    7056:	00 00       	nop
    7058:	1a c0       	rjmp	.+52     	; 0x708e <__bad_interrupt>
    705a:	00 00       	nop
    705c:	18 c0       	rjmp	.+48     	; 0x708e <__bad_interrupt>
    705e:	00 00       	nop
    7060:	16 c0       	rjmp	.+44     	; 0x708e <__bad_interrupt>
    7062:	00 00       	nop
    7064:	14 c0       	rjmp	.+40     	; 0x708e <__bad_interrupt>
	...

00007068 <__ctors_end>:
    7068:	11 24       	eor	r1, r1
    706a:	1f be       	out	0x3f, r1	; 63
    706c:	cf ef       	ldi	r28, 0xFF	; 255
    706e:	d8 e0       	ldi	r29, 0x08	; 8
    7070:	de bf       	out	0x3e, r29	; 62
    7072:	cd bf       	out	0x3d, r28	; 61

00007074 <__do_copy_data>:
    7074:	11 e0       	ldi	r17, 0x01	; 1
    7076:	a0 e0       	ldi	r26, 0x00	; 0
    7078:	b1 e0       	ldi	r27, 0x01	; 1
    707a:	ec e7       	ldi	r30, 0x7C	; 124
    707c:	f2 e7       	ldi	r31, 0x72	; 114
    707e:	02 c0       	rjmp	.+4      	; 0x7084 <__do_copy_data+0x10>
    7080:	05 90       	lpm	r0, Z+
    7082:	0d 92       	st	X+, r0
    7084:	a4 32       	cpi	r26, 0x24	; 36
    7086:	b1 07       	cpc	r27, r17
    7088:	d9 f7       	brne	.-10     	; 0x7080 <__do_copy_data+0xc>
    708a:	2c d0       	rcall	.+88     	; 0x70e4 <main>
    708c:	dd c0       	rjmp	.+442    	; 0x7248 <exit>

0000708e <__bad_interrupt>:
    708e:	b8 cf       	rjmp	.-144    	; 0x7000 <__vectors>

00007090 <Init_Uart>:

void Init_Uart()
{
// setting the baud rate  based on the datasheet
#define UART_BAUD 102
    UBRR0H = (unsigned char)(UART_BAUD >> 8); // 0x00 // TODO: change it to value
    7090:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
    UBRR0L = (unsigned char)UART_BAUD;        // 0x0C
    7094:	86 e6       	ldi	r24, 0x66	; 102
    7096:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    // enabling TX & RX
    UCSR0B = (1 << TXEN0) | (1 << RXEN0);
    709a:	88 e1       	ldi	r24, 0x18	; 24
    709c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    UCSR0A = (1 << UDRE0);
    70a0:	80 e2       	ldi	r24, 0x20	; 32
    70a2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // Set frame: 8data, 1 stop
    70a6:	86 e0       	ldi	r24, 0x06	; 6
    70a8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
}
    70ac:	08 95       	ret

000070ae <Uart_Receive>:
uint8_t Uart_Receive(void)
{
    /* Wait for data to be received */
    while (!(UCSR0A & (1 << RXC0)))
    70ae:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    70b2:	87 ff       	sbrs	r24, 7
    70b4:	fc cf       	rjmp	.-8      	; 0x70ae <Uart_Receive>
        ;
    /* Get and return received data from buffer */
    return UDR0;
    70b6:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
}
    70ba:	08 95       	ret

000070bc <Uart_Transmit>:
void Uart_Transmit(unsigned char data)
{
    // Set DE/RI pin

    /* Wait for empty transmit buffer */
    while (!(UCSR0A & (1 << UDRE0)))
    70bc:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    70c0:	95 ff       	sbrs	r25, 5
    70c2:	fc cf       	rjmp	.-8      	; 0x70bc <Uart_Transmit>
        ;
    UDR0 = data;
    70c4:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>

    // Clear DE/RI pin
}
    70c8:	08 95       	ret

000070ca <USART_transmit_string>:

void USART_transmit_string(char *s)
{
    70ca:	cf 93       	push	r28
    70cc:	df 93       	push	r29
    70ce:	ec 01       	movw	r28, r24
#ifdef DEBUG_STRINGS
    // transmit character until NULL is reached
    while (*s > 0)
    70d0:	89 91       	ld	r24, Y+
    70d2:	18 16       	cp	r1, r24
    70d4:	1c f0       	brlt	.+6      	; 0x70dc <USART_transmit_string+0x12>
        Uart_Transmit(*s++);
#endif
}
    70d6:	df 91       	pop	r29
    70d8:	cf 91       	pop	r28
    70da:	08 95       	ret
void USART_transmit_string(char *s)
{
#ifdef DEBUG_STRINGS
    // transmit character until NULL is reached
    while (*s > 0)
        Uart_Transmit(*s++);
    70dc:	ef df       	rcall	.-34     	; 0x70bc <Uart_Transmit>
    70de:	f8 cf       	rjmp	.-16     	; 0x70d0 <USART_transmit_string+0x6>

000070e0 <USART_transmit_num>:
#endif
}

void USART_transmit_num(uint8_t num)
{
    Uart_Transmit('0' + num);
    70e0:	80 5d       	subi	r24, 0xD0	; 208
    70e2:	ec cf       	rjmp	.-40     	; 0x70bc <Uart_Transmit>

000070e4 <main>:
    REQUEST_INDEX_ARGUMENT_1,
    REQUEST_INDEX_ARGUMENT_0,
} Request_index;

main()
{
    70e4:	cf 93       	push	r28
    70e6:	df 93       	push	r29
    70e8:	cd b7       	in	r28, 0x3d	; 61
    70ea:	de b7       	in	r29, 0x3e	; 62
    70ec:	c0 58       	subi	r28, 0x80	; 128
    70ee:	d1 09       	sbc	r29, r1
    70f0:	0f b6       	in	r0, 0x3f	; 63
    70f2:	f8 94       	cli
    70f4:	de bf       	out	0x3e, r29	; 62
    70f6:	0f be       	out	0x3f, r0	; 63
    70f8:	cd bf       	out	0x3d, r28	; 61
    Init_Uart();
    70fa:	ca df       	rcall	.-108    	; 0x7090 <Init_Uart>

    State state = STATE_START;
    70fc:	90 e0       	ldi	r25, 0x00	; 0
    70fe:	80 e0       	ldi	r24, 0x00	; 0
    7100:	9e 01       	movw	r18, r28
    7102:	2f 5f       	subi	r18, 0xFF	; 255
    7104:	3f 4f       	sbci	r19, 0xFF	; 255
    7106:	59 01       	movw	r10, r18
    7108:	4e 01       	movw	r8, r28
    710a:	31 e8       	ldi	r19, 0x81	; 129
    710c:	83 0e       	add	r8, r19
    710e:	91 1c       	adc	r9, r1
                // Uart_Transmit(0xAA);
                // continue;

                // Write data to flash
                // Do erase before programming
                boot_page_erase(page);
    7110:	23 e0       	ldi	r18, 0x03	; 3
    7112:	32 2e       	mov	r3, r18
                    boot_page_fill(page + i, w);
                }

                boot_page_write(page); // Store buffer in flash page.
                boot_spm_busy_wait();  // Wait until the memory is written.
                boot_rww_enable();
    7114:	31 e1       	ldi	r19, 0x11	; 17
    7116:	43 2e       	mov	r4, r19
    uint8_t rx_buffer[3];
    uint8_t rx_data[SPM_PAGESIZE];

    while (1)
    {
        switch (state)
    7118:	81 30       	cpi	r24, 0x01	; 1
    711a:	91 05       	cpc	r25, r1
    711c:	29 f0       	breq	.+10     	; 0x7128 <main+0x44>
    711e:	02 97       	sbiw	r24, 0x02	; 2
    7120:	91 f0       	breq	.+36     	; 0x7146 <main+0x62>
        {

        case STATE_START:
        {
            USART_transmit_string("\r\nStart\r\n");
    7122:	80 e0       	ldi	r24, 0x00	; 0
    7124:	91 e0       	ldi	r25, 0x01	; 1
            break;
        }

        case STATE_POOL_REQUEST:
        {
            if (Uart_Receive() == 0x55) // Start byte
    7126:	d1 df       	rcall	.-94     	; 0x70ca <USART_transmit_string>
    7128:	c2 df       	rcall	.-124    	; 0x70ae <Uart_Receive>
    712a:	85 35       	cpi	r24, 0x55	; 85
            {
                // USART_transmit_string("\r\n CMD=");
                rx_buffer[REQUEST_INDEX_COMMAND] = Uart_Receive();    // Command
    712c:	d1 f4       	brne	.+52     	; 0x7162 <main+0x7e>
                rx_buffer[REQUEST_INDEX_ARGUMENT_0] = Uart_Receive(); // Argument_0 - PAGE  3
    712e:	bf df       	rcall	.-130    	; 0x70ae <Uart_Receive>
                rx_buffer[REQUEST_INDEX_ARGUMENT_1] = Uart_Receive(); // Argument_1 - PAGE  2
    7130:	18 2f       	mov	r17, r24
                rx_buffer[REQUEST_INDEX_ARGUMENT_2] = Uart_Receive(); // Argument_2 - PAGE  1
    7132:	bd df       	rcall	.-134    	; 0x70ae <Uart_Receive>
    7134:	bc df       	rcall	.-136    	; 0x70ae <Uart_Receive>
                rx_buffer[REQUEST_INDEX_ARGUMENT_3] = Uart_Receive(); // Argument_3 - PAGE  0
    7136:	bb df       	rcall	.-138    	; 0x70ae <Uart_Receive>
    7138:	68 2e       	mov	r6, r24
    713a:	b9 df       	rcall	.-142    	; 0x70ae <Uart_Receive>
                rx_buffer[REQUEST_INDEX_ARGUMENT_4] = Uart_Receive(); // Argument_4 - CRC16 1
    713c:	78 2e       	mov	r7, r24
    713e:	b7 df       	rcall	.-146    	; 0x70ae <Uart_Receive>
    7140:	58 2e       	mov	r5, r24
                rx_buffer[REQUEST_INDEX_ARGUMENT_5] = Uart_Receive(); // Argument_5 - CRC16 0
    7142:	b5 df       	rcall	.-150    	; 0x70ae <Uart_Receive>
    7144:	08 2f       	mov	r16, r24
    7146:	96 2d       	mov	r25, r6

            case COMMAND_WRITE_EEPROM_BYTE:
            {
                uint16_t address;
                address = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                address |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    7148:	87 2d       	mov	r24, r7
    714a:	16 30       	cpi	r17, 0x06	; 6
            break;
        }

        case STATE_PARSE_REQUEST:
        {
            switch (rx_buffer[REQUEST_INDEX_COMMAND]) // Command
    714c:	09 f4       	brne	.+2      	; 0x7150 <main+0x6c>
    714e:	68 c0       	rjmp	.+208    	; 0x7220 <main+0x13c>
    7150:	58 f4       	brcc	.+22     	; 0x7168 <main+0x84>
    7152:	13 30       	cpi	r17, 0x03	; 3
    7154:	f1 f0       	breq	.+60     	; 0x7192 <main+0xae>
    7156:	15 30       	cpi	r17, 0x05	; 5
    7158:	09 f4       	brne	.+2      	; 0x715c <main+0x78>
    715a:	5a c0       	rjmp	.+180    	; 0x7210 <main+0x12c>
    715c:	82 e0       	ldi	r24, 0x02	; 2
    715e:	90 e0       	ldi	r25, 0x00	; 0
    7160:	db cf       	rjmp	.-74     	; 0x7118 <main+0x34>
    7162:	81 e0       	ldi	r24, 0x01	; 1
    7164:	90 e0       	ldi	r25, 0x00	; 0
    7166:	d8 cf       	rjmp	.-80     	; 0x7118 <main+0x34>
    7168:	17 30       	cpi	r17, 0x07	; 7
    716a:	09 f4       	brne	.+2      	; 0x716e <main+0x8a>
    716c:	65 c0       	rjmp	.+202    	; 0x7238 <main+0x154>
            }

            // Run main application
            case COMMAND_GO_TO_APPLICATION:
            {
                USART_transmit_string(" GO_APP=");
    716e:	18 3c       	cpi	r17, 0xC8	; 200
    7170:	a9 f7       	brne	.-22     	; 0x715c <main+0x78>
    7172:	8b e1       	ldi	r24, 0x1B	; 27

                Uart_Transmit(0x55);
    7174:	91 e0       	ldi	r25, 0x01	; 1
    7176:	a9 df       	rcall	.-174    	; 0x70ca <USART_transmit_string>
                Uart_Transmit(RESPONSE_GOING_TO_APP);
    7178:	85 e5       	ldi	r24, 0x55	; 85
    717a:	a0 df       	rcall	.-192    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(RESPONSE_OK);
    717c:	81 e0       	ldi	r24, 0x01	; 1
    717e:	9e df       	rcall	.-196    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(0xAA);
    7180:	80 e0       	ldi	r24, 0x00	; 0
    7182:	9c df       	rcall	.-200    	; 0x70bc <Uart_Transmit>
    7184:	8a ea       	ldi	r24, 0xAA	; 170

                asm("jmp 0");
    7186:	9a df       	rcall	.-204    	; 0x70bc <Uart_Transmit>
                uint8_t r = eeprom_read_byte(address);

                Uart_Transmit(0x55);
                Uart_Transmit(r);
                Uart_Transmit(RESPONSE_OK);
                Uart_Transmit(0xAA);
    7188:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
            {

            // Get CRC16, Uart_Transmit, data and write it to flash if it's valid
            case COMMAND_WRITE_FLASH_PAGE:
            {
                USART_transmit_string(" Fl=start");
    718c:	85 e0       	ldi	r24, 0x05	; 5
    718e:	96 df       	rcall	.-212    	; 0x70bc <Uart_Transmit>
    7190:	cb cf       	rjmp	.-106    	; 0x7128 <main+0x44>
    7192:	8a e0       	ldi	r24, 0x0A	; 10

                // Parse CRC16
                uint16_t crc16;
                crc16 = rx_buffer[REQUEST_INDEX_ARGUMENT_4] << 8;
                crc16 |= rx_buffer[REQUEST_INDEX_ARGUMENT_5];
                Uart_Transmit(crc16 >> 8);
    7194:	91 e0       	ldi	r25, 0x01	; 1
    7196:	99 df       	rcall	.-206    	; 0x70ca <USART_transmit_string>
    7198:	85 2d       	mov	r24, r5
                Uart_Transmit(crc16);
    719a:	90 df       	rcall	.-224    	; 0x70bc <Uart_Transmit>
    719c:	80 2f       	mov	r24, r16
    719e:	8e df       	rcall	.-228    	; 0x70bc <Uart_Transmit>

                // Parse page
                page = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    71a0:	f6 2c       	mov	r15, r6
    71a2:	e7 2c       	mov	r14, r7
                Uart_Transmit(page >> 8);
    71a4:	86 2d       	mov	r24, r6
    71a6:	8a df       	rcall	.-236    	; 0x70bc <Uart_Transmit>
    71a8:	87 2d       	mov	r24, r7
                Uart_Transmit(page);
    71aa:	88 df       	rcall	.-240    	; 0x70bc <Uart_Transmit>
    71ac:	65 01       	movw	r12, r10
    71ae:	7f df       	rcall	.-258    	; 0x70ae <Uart_Receive>
    71b0:	f6 01       	movw	r30, r12

                // Get page (0,128,256..)
                for (uint16_t i = 0; i < SPM_PAGESIZE; i++)
                {
                    rx_data[i] = Uart_Receive();
    71b2:	81 93       	st	Z+, r24
    71b4:	6f 01       	movw	r12, r30
    71b6:	e8 15       	cp	r30, r8
    71b8:	f9 05       	cpc	r31, r9
    71ba:	c9 f7       	brne	.-14     	; 0x71ae <main+0xca>
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
                Uart_Transmit(page >> 8);
                Uart_Transmit(page);

                // Get page (0,128,256..)
                for (uint16_t i = 0; i < SPM_PAGESIZE; i++)
    71bc:	f7 01       	movw	r30, r14
    71be:	30 92 57 00 	sts	0x0057, r3	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
                // Uart_Transmit(0xAA);
                // continue;

                // Write data to flash
                // Do erase before programming
                boot_page_erase(page);
    71c2:	e8 95       	spm
    71c4:	07 b6       	in	r0, 0x37	; 55
    71c6:	00 fc       	sbrc	r0, 0
    71c8:	fd cf       	rjmp	.-6      	; 0x71c4 <main+0xe0>
                boot_spm_busy_wait(); // Wait until the memory is written.
    71ca:	d5 01       	movw	r26, r10
    71cc:	21 e0       	ldi	r18, 0x01	; 1
    71ce:	a7 01       	movw	r20, r14
    71d0:	4a 19       	sub	r20, r10

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
                {
                    uint16_t w = rx_data[i];
                    w |= rx_data[i + 1] << 8;
                    boot_page_fill(page + i, w);
    71d2:	5b 09       	sbc	r21, r11
    71d4:	8c 91       	ld	r24, X
    71d6:	fa 01       	movw	r30, r20
    71d8:	ea 0f       	add	r30, r26
                boot_page_erase(page);
                boot_spm_busy_wait(); // Wait until the memory is written.

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
                {
                    uint16_t w = rx_data[i];
    71da:	fb 1f       	adc	r31, r27
                    w |= rx_data[i + 1] << 8;
                    boot_page_fill(page + i, w);
    71dc:	11 96       	adiw	r26, 0x01	; 1
    71de:	9c 91       	ld	r25, X
    71e0:	11 97       	sbiw	r26, 0x01	; 1
                boot_spm_busy_wait(); // Wait until the memory is written.

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
                {
                    uint16_t w = rx_data[i];
                    w |= rx_data[i + 1] << 8;
    71e2:	0c 01       	movw	r0, r24
    71e4:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
                    boot_page_fill(page + i, w);
    71e8:	e8 95       	spm
    71ea:	11 24       	eor	r1, r1
    71ec:	12 96       	adiw	r26, 0x02	; 2
    71ee:	ac 15       	cp	r26, r12
                // Write data to flash
                // Do erase before programming
                boot_page_erase(page);
                boot_spm_busy_wait(); // Wait until the memory is written.

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
    71f0:	bd 05       	cpc	r27, r13
    71f2:	81 f7       	brne	.-32     	; 0x71d4 <main+0xf0>
                    uint16_t w = rx_data[i];
                    w |= rx_data[i + 1] << 8;
                    boot_page_fill(page + i, w);
                }

                boot_page_write(page); // Store buffer in flash page.
    71f4:	85 e0       	ldi	r24, 0x05	; 5
    71f6:	f7 01       	movw	r30, r14
    71f8:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
                boot_spm_busy_wait();  // Wait until the memory is written.
    71fc:	e8 95       	spm
    71fe:	07 b6       	in	r0, 0x37	; 55
                boot_rww_enable();
    7200:	00 fc       	sbrc	r0, 0
    7202:	fd cf       	rjmp	.-6      	; 0x71fe <main+0x11a>

                // Uart_Transmit(RESPONSE_FLASH_WRITTEN);
                // Uart_Transmit(RESPONSE_FLASH_WRITTEN);
                // Uart_Transmit(RESPONSE_FLASH_WRITTEN);

                USART_transmit_string(" Fl=ok");
    7204:	40 92 57 00 	sts	0x0057, r4	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7208:	e8 95       	spm
            case COMMAND_READ_FLASH_PAGE_SIZE:
            {
                // USART_transmit_string(" R_PG_SZ=");

                // Send pagesize to master [Startbyte MSB LSB Endbyte]
                Uart_Transmit(0x55);
    720a:	84 e1       	ldi	r24, 0x14	; 20
    720c:	91 e0       	ldi	r25, 0x01	; 1
                Uart_Transmit(SPM_PAGESIZE >> 8);
    720e:	8b cf       	rjmp	.-234    	; 0x7126 <main+0x42>
    7210:	85 e5       	ldi	r24, 0x55	; 85
                Uart_Transmit(SPM_PAGESIZE);
    7212:	54 df       	rcall	.-344    	; 0x70bc <Uart_Transmit>
                eeprom_busy_wait();
                uint8_t r = eeprom_read_byte(address);

                Uart_Transmit(0x55);
                Uart_Transmit(r);
                Uart_Transmit(RESPONSE_OK);
    7214:	80 e0       	ldi	r24, 0x00	; 0
    7216:	52 df       	rcall	.-348    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(0xAA);
    7218:	80 e8       	ldi	r24, 0x80	; 128
    721a:	50 df       	rcall	.-352    	; 0x70bc <Uart_Transmit>
            case COMMAND_WRITE_EEPROM_BYTE:
            {
                uint16_t address;
                address = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                address |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
                eeprom_busy_wait();
    721c:	8a ea       	ldi	r24, 0xAA	; 170
    721e:	b7 cf       	rjmp	.-146    	; 0x718e <main+0xaa>
                eeprom_write_byte(address,rx_buffer[REQUEST_INDEX_ARGUMENT_5]);
    7220:	f9 99       	sbic	0x1f, 1	; 31
    7222:	fe cf       	rjmp	.-4      	; 0x7220 <main+0x13c>
    7224:	60 2f       	mov	r22, r16
                eeprom_busy_wait();
    7226:	1a d0       	rcall	.+52     	; 0x725c <eeprom_write_byte>
    7228:	f9 99       	sbic	0x1f, 1	; 31

                Uart_Transmit(0x55);
    722a:	fe cf       	rjmp	.-4      	; 0x7228 <main+0x144>
    722c:	85 e5       	ldi	r24, 0x55	; 85
    722e:	46 df       	rcall	.-372    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(rx_buffer[REQUEST_INDEX_ARGUMENT_5]);
    7230:	80 2f       	mov	r24, r16

                eeprom_busy_wait();
                uint8_t r = eeprom_read_byte(address);

                Uart_Transmit(0x55);
                Uart_Transmit(r);
    7232:	44 df       	rcall	.-376    	; 0x70bc <Uart_Transmit>
    7234:	80 e0       	ldi	r24, 0x00	; 0
                Uart_Transmit(RESPONSE_OK);
    7236:	f1 cf       	rjmp	.-30     	; 0x721a <main+0x136>
    7238:	f9 99       	sbic	0x1f, 1	; 31
            {
                uint16_t address;
                address = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                address |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];

                eeprom_busy_wait();
    723a:	fe cf       	rjmp	.-4      	; 0x7238 <main+0x154>
    723c:	07 d0       	rcall	.+14     	; 0x724c <eeprom_read_byte>
                uint8_t r = eeprom_read_byte(address);
    723e:	f8 2e       	mov	r15, r24
    7240:	85 e5       	ldi	r24, 0x55	; 85
    7242:	3c df       	rcall	.-392    	; 0x70bc <Uart_Transmit>

                Uart_Transmit(0x55);
    7244:	8f 2d       	mov	r24, r15
    7246:	f5 cf       	rjmp	.-22     	; 0x7232 <main+0x14e>

00007248 <exit>:
    7248:	f8 94       	cli
                Uart_Transmit(r);
    724a:	16 c0       	rjmp	.+44     	; 0x7278 <_exit>

0000724c <eeprom_read_byte>:
    724c:	f9 99       	sbic	0x1f, 1	; 31
    724e:	fe cf       	rjmp	.-4      	; 0x724c <eeprom_read_byte>
    7250:	92 bd       	out	0x22, r25	; 34
    7252:	81 bd       	out	0x21, r24	; 33
    7254:	f8 9a       	sbi	0x1f, 0	; 31
    7256:	99 27       	eor	r25, r25
    7258:	80 b5       	in	r24, 0x20	; 32
    725a:	08 95       	ret

0000725c <eeprom_write_byte>:
    725c:	26 2f       	mov	r18, r22

0000725e <eeprom_write_r18>:
    725e:	f9 99       	sbic	0x1f, 1	; 31
    7260:	fe cf       	rjmp	.-4      	; 0x725e <eeprom_write_r18>
    7262:	1f ba       	out	0x1f, r1	; 31
    7264:	92 bd       	out	0x22, r25	; 34
    7266:	81 bd       	out	0x21, r24	; 33
    7268:	20 bd       	out	0x20, r18	; 32
    726a:	0f b6       	in	r0, 0x3f	; 63
    726c:	f8 94       	cli
    726e:	fa 9a       	sbi	0x1f, 2	; 31
    7270:	f9 9a       	sbi	0x1f, 1	; 31
    7272:	0f be       	out	0x3f, r0	; 63
    7274:	01 96       	adiw	r24, 0x01	; 1
    7276:	08 95       	ret

00007278 <_exit>:
    7278:	f8 94       	cli

0000727a <__stop_program>:
    727a:	ff cf       	rjmp	.-2      	; 0x727a <__stop_program>
