
bootloader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000038  00800100  0000730c  00000380  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000030c  00007000  00007000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000011  00000000  00000000  000003b8  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000003cc  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000068  00000000  00000000  00000410  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000e1c  00000000  00000000  00000478  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000007c5  00000000  00000000  00001294  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000047b  00000000  00000000  00001a59  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000094  00000000  00000000  00001ed4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000628  00000000  00000000  00001f68  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000002de  00000000  00000000  00002590  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  0000286e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	33 c0       	rjmp	.+102    	; 0x7068 <__ctors_end>
    7002:	00 00       	nop
    7004:	44 c0       	rjmp	.+136    	; 0x708e <__bad_interrupt>
    7006:	00 00       	nop
    7008:	42 c0       	rjmp	.+132    	; 0x708e <__bad_interrupt>
    700a:	00 00       	nop
    700c:	40 c0       	rjmp	.+128    	; 0x708e <__bad_interrupt>
    700e:	00 00       	nop
    7010:	3e c0       	rjmp	.+124    	; 0x708e <__bad_interrupt>
    7012:	00 00       	nop
    7014:	3c c0       	rjmp	.+120    	; 0x708e <__bad_interrupt>
    7016:	00 00       	nop
    7018:	3a c0       	rjmp	.+116    	; 0x708e <__bad_interrupt>
    701a:	00 00       	nop
    701c:	38 c0       	rjmp	.+112    	; 0x708e <__bad_interrupt>
    701e:	00 00       	nop
    7020:	36 c0       	rjmp	.+108    	; 0x708e <__bad_interrupt>
    7022:	00 00       	nop
    7024:	34 c0       	rjmp	.+104    	; 0x708e <__bad_interrupt>
    7026:	00 00       	nop
    7028:	32 c0       	rjmp	.+100    	; 0x708e <__bad_interrupt>
    702a:	00 00       	nop
    702c:	30 c0       	rjmp	.+96     	; 0x708e <__bad_interrupt>
    702e:	00 00       	nop
    7030:	2e c0       	rjmp	.+92     	; 0x708e <__bad_interrupt>
    7032:	00 00       	nop
    7034:	2c c0       	rjmp	.+88     	; 0x708e <__bad_interrupt>
    7036:	00 00       	nop
    7038:	2a c0       	rjmp	.+84     	; 0x708e <__bad_interrupt>
    703a:	00 00       	nop
    703c:	28 c0       	rjmp	.+80     	; 0x708e <__bad_interrupt>
    703e:	00 00       	nop
    7040:	26 c0       	rjmp	.+76     	; 0x708e <__bad_interrupt>
    7042:	00 00       	nop
    7044:	24 c0       	rjmp	.+72     	; 0x708e <__bad_interrupt>
    7046:	00 00       	nop
    7048:	22 c0       	rjmp	.+68     	; 0x708e <__bad_interrupt>
    704a:	00 00       	nop
    704c:	20 c0       	rjmp	.+64     	; 0x708e <__bad_interrupt>
    704e:	00 00       	nop
    7050:	1e c0       	rjmp	.+60     	; 0x708e <__bad_interrupt>
    7052:	00 00       	nop
    7054:	1c c0       	rjmp	.+56     	; 0x708e <__bad_interrupt>
    7056:	00 00       	nop
    7058:	1a c0       	rjmp	.+52     	; 0x708e <__bad_interrupt>
    705a:	00 00       	nop
    705c:	18 c0       	rjmp	.+48     	; 0x708e <__bad_interrupt>
    705e:	00 00       	nop
    7060:	16 c0       	rjmp	.+44     	; 0x708e <__bad_interrupt>
    7062:	00 00       	nop
    7064:	14 c0       	rjmp	.+40     	; 0x708e <__bad_interrupt>
	...

00007068 <__ctors_end>:
    7068:	11 24       	eor	r1, r1
    706a:	1f be       	out	0x3f, r1	; 63
    706c:	cf ef       	ldi	r28, 0xFF	; 255
    706e:	d8 e0       	ldi	r29, 0x08	; 8
    7070:	de bf       	out	0x3e, r29	; 62
    7072:	cd bf       	out	0x3d, r28	; 61

00007074 <__do_copy_data>:
    7074:	11 e0       	ldi	r17, 0x01	; 1
    7076:	a0 e0       	ldi	r26, 0x00	; 0
    7078:	b1 e0       	ldi	r27, 0x01	; 1
    707a:	ec e0       	ldi	r30, 0x0C	; 12
    707c:	f3 e7       	ldi	r31, 0x73	; 115
    707e:	02 c0       	rjmp	.+4      	; 0x7084 <__do_copy_data+0x10>
    7080:	05 90       	lpm	r0, Z+
    7082:	0d 92       	st	X+, r0
    7084:	a8 33       	cpi	r26, 0x38	; 56
    7086:	b1 07       	cpc	r27, r17
    7088:	d9 f7       	brne	.-10     	; 0x7080 <__do_copy_data+0xc>
    708a:	2c d0       	rcall	.+88     	; 0x70e4 <main>
    708c:	25 c1       	rjmp	.+586    	; 0x72d8 <exit>

0000708e <__bad_interrupt>:
    708e:	b8 cf       	rjmp	.-144    	; 0x7000 <__vectors>

00007090 <Init_Uart>:

void Init_Uart()
{
// setting the baud rate  based on the datasheet
#define UART_BAUD 102
    UBRR0H = (unsigned char)(UART_BAUD >> 8); // 0x00 // TODO: change it to value
    7090:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
    UBRR0L = (unsigned char)UART_BAUD;        // 0x0C
    7094:	86 e6       	ldi	r24, 0x66	; 102
    7096:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    // enabling TX & RX
    UCSR0B = (1 << TXEN0) | (1 << RXEN0);
    709a:	88 e1       	ldi	r24, 0x18	; 24
    709c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    UCSR0A = (1 << UDRE0);
    70a0:	80 e2       	ldi	r24, 0x20	; 32
    70a2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // Set frame: 8data, 1 stop
    70a6:	86 e0       	ldi	r24, 0x06	; 6
    70a8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
}
    70ac:	08 95       	ret

000070ae <Uart_Receive>:
uint8_t Uart_Receive(void)
{
    /* Wait for data to be received */
    while (!(UCSR0A & (1 << RXC0)))
    70ae:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    70b2:	87 ff       	sbrs	r24, 7
    70b4:	fc cf       	rjmp	.-8      	; 0x70ae <Uart_Receive>
        ;
    /* Get and return received data from buffer */
    return UDR0;
    70b6:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
}
    70ba:	08 95       	ret

000070bc <Uart_Transmit>:
void Uart_Transmit(unsigned char data)
{
    // Set DE/RI pin

    /* Wait for empty transmit buffer */
    while (!(UCSR0A & (1 << UDRE0)))
    70bc:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    70c0:	95 ff       	sbrs	r25, 5
    70c2:	fc cf       	rjmp	.-8      	; 0x70bc <Uart_Transmit>
        ;
    UDR0 = data;
    70c4:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>

    // Clear DE/RI pin
}
    70c8:	08 95       	ret

000070ca <USART_transmit_string>:

void USART_transmit_string(char *s)
{
    70ca:	cf 93       	push	r28
    70cc:	df 93       	push	r29
    70ce:	ec 01       	movw	r28, r24
#ifdef DEBUG_STRINGS
    // transmit character until NULL is reached
    while (*s > 0)
    70d0:	89 91       	ld	r24, Y+
    70d2:	18 16       	cp	r1, r24
    70d4:	1c f0       	brlt	.+6      	; 0x70dc <USART_transmit_string+0x12>
        Uart_Transmit(*s++);
#endif
}
    70d6:	df 91       	pop	r29
    70d8:	cf 91       	pop	r28
    70da:	08 95       	ret
void USART_transmit_string(char *s)
{
#ifdef DEBUG_STRINGS
    // transmit character until NULL is reached
    while (*s > 0)
        Uart_Transmit(*s++);
    70dc:	ef df       	rcall	.-34     	; 0x70bc <Uart_Transmit>
    70de:	f8 cf       	rjmp	.-16     	; 0x70d0 <USART_transmit_string+0x6>

000070e0 <USART_transmit_num>:
#endif
}

void USART_transmit_num(uint8_t num)
{
    Uart_Transmit('0' + num);
    70e0:	80 5d       	subi	r24, 0xD0	; 208
    70e2:	ec cf       	rjmp	.-40     	; 0x70bc <Uart_Transmit>

000070e4 <main>:
    REQUEST_INDEX_ARGUMENT_1,
    REQUEST_INDEX_ARGUMENT_0,
} Request_index;

main()
{
    70e4:	cf 93       	push	r28
    70e6:	df 93       	push	r29
    70e8:	cd b7       	in	r28, 0x3d	; 61
    70ea:	de b7       	in	r29, 0x3e	; 62
    70ec:	c0 58       	subi	r28, 0x80	; 128
    70ee:	d1 09       	sbc	r29, r1
    70f0:	0f b6       	in	r0, 0x3f	; 63
    70f2:	f8 94       	cli
    70f4:	de bf       	out	0x3e, r29	; 62
    70f6:	0f be       	out	0x3f, r0	; 63
    70f8:	cd bf       	out	0x3d, r28	; 61
    Init_Uart();
    70fa:	ca df       	rcall	.-108    	; 0x7090 <Init_Uart>

    State state = STATE_START;
    70fc:	90 e0       	ldi	r25, 0x00	; 0
    70fe:	80 e0       	ldi	r24, 0x00	; 0
            }

            case COMMAND_READ_DEVICE_SIGNATURE:
            {
                Uart_Transmit(0x55);
                Uart_Transmit(boot_signature_byte_get(0x00)); // Device signature 1
    7100:	21 e2       	ldi	r18, 0x21	; 33
    7102:	92 2e       	mov	r9, r18
    7104:	9e 01       	movw	r18, r28
    7106:	2f 5f       	subi	r18, 0xFF	; 255
    7108:	3f 4f       	sbci	r19, 0xFF	; 255
    710a:	29 01       	movw	r4, r18
    710c:	1e 01       	movw	r2, r28
    710e:	31 e8       	ldi	r19, 0x81	; 129
    7110:	23 0e       	add	r2, r19
    7112:	31 1c       	adc	r3, r1
    uint8_t rx_buffer[3];
    uint8_t rx_data[SPM_PAGESIZE];

    while (1)
    {
        switch (state)
    7114:	81 30       	cpi	r24, 0x01	; 1
    7116:	91 05       	cpc	r25, r1
    7118:	29 f0       	breq	.+10     	; 0x7124 <main+0x40>
    711a:	02 97       	sbiw	r24, 0x02	; 2
    711c:	91 f0       	breq	.+36     	; 0x7142 <main+0x5e>
        {

        case STATE_START:
        {
            USART_transmit_string("\r\nStart\r\n");
    711e:	80 e0       	ldi	r24, 0x00	; 0
    7120:	91 e0       	ldi	r25, 0x01	; 1
            break;
        }

        case STATE_POOL_REQUEST:
        {
            if (Uart_Receive() == 0x55) // Start byte
    7122:	d3 df       	rcall	.-90     	; 0x70ca <USART_transmit_string>
    7124:	c4 df       	rcall	.-120    	; 0x70ae <Uart_Receive>
    7126:	85 35       	cpi	r24, 0x55	; 85
            {
                // USART_transmit_string("\r\n CMD=");
                rx_buffer[REQUEST_INDEX_COMMAND] = Uart_Receive();    // Command
    7128:	f9 f4       	brne	.+62     	; 0x7168 <main+0x84>
                rx_buffer[REQUEST_INDEX_ARGUMENT_0] = Uart_Receive(); // Argument_0 - PAGE  3
    712a:	c1 df       	rcall	.-126    	; 0x70ae <Uart_Receive>
                rx_buffer[REQUEST_INDEX_ARGUMENT_1] = Uart_Receive(); // Argument_1 - PAGE  2
    712c:	f8 2e       	mov	r15, r24
                rx_buffer[REQUEST_INDEX_ARGUMENT_2] = Uart_Receive(); // Argument_2 - PAGE  1
    712e:	bf df       	rcall	.-130    	; 0x70ae <Uart_Receive>
    7130:	be df       	rcall	.-132    	; 0x70ae <Uart_Receive>
                rx_buffer[REQUEST_INDEX_ARGUMENT_3] = Uart_Receive(); // Argument_3 - PAGE  0
    7132:	bd df       	rcall	.-134    	; 0x70ae <Uart_Receive>
    7134:	c8 2e       	mov	r12, r24
    7136:	bb df       	rcall	.-138    	; 0x70ae <Uart_Receive>
                rx_buffer[REQUEST_INDEX_ARGUMENT_4] = Uart_Receive(); // Argument_4 - CRC16 1
    7138:	d8 2e       	mov	r13, r24
    713a:	b9 df       	rcall	.-142    	; 0x70ae <Uart_Receive>
    713c:	88 2e       	mov	r8, r24
                rx_buffer[REQUEST_INDEX_ARGUMENT_5] = Uart_Receive(); // Argument_5 - CRC16 0
    713e:	b7 df       	rcall	.-146    	; 0x70ae <Uart_Receive>
    7140:	e8 2e       	mov	r14, r24
    7142:	86 e0       	ldi	r24, 0x06	; 6
            break;
        }

        case STATE_PARSE_REQUEST:
        {
            switch (rx_buffer[REQUEST_INDEX_COMMAND]) // Command
    7144:	f8 16       	cp	r15, r24
    7146:	09 f4       	brne	.+2      	; 0x714a <main+0x66>
    7148:	9b c0       	rjmp	.+310    	; 0x7280 <main+0x19c>
    714a:	8f 15       	cp	r24, r15
    714c:	80 f0       	brcs	.+32     	; 0x716e <main+0x8a>
    714e:	e4 e0       	ldi	r30, 0x04	; 4
    7150:	fe 16       	cp	r15, r30
    7152:	39 f1       	breq	.+78     	; 0x71a2 <main+0xbe>
    7154:	ef 15       	cp	r30, r15
    7156:	08 f4       	brcc	.+2      	; 0x715a <main+0x76>
    7158:	8b c0       	rjmp	.+278    	; 0x7270 <main+0x18c>
    715a:	f3 e0       	ldi	r31, 0x03	; 3
    715c:	ff 16       	cp	r15, r31
    715e:	09 f4       	brne	.+2      	; 0x7162 <main+0x7e>
    7160:	46 c0       	rjmp	.+140    	; 0x71ee <main+0x10a>
    7162:	82 e0       	ldi	r24, 0x02	; 2
    7164:	90 e0       	ldi	r25, 0x00	; 0
    7166:	d6 cf       	rjmp	.-84     	; 0x7114 <main+0x30>
    7168:	81 e0       	ldi	r24, 0x01	; 1
    716a:	90 e0       	ldi	r25, 0x00	; 0
    716c:	d3 cf       	rjmp	.-90     	; 0x7114 <main+0x30>
    716e:	28 e0       	ldi	r18, 0x08	; 8
    7170:	f2 16       	cp	r15, r18
    7172:	09 f4       	brne	.+2      	; 0x7176 <main+0x92>
    7174:	9d c0       	rjmp	.+314    	; 0x72b0 <main+0x1cc>
    7176:	f2 16       	cp	r15, r18
    7178:	08 f4       	brcc	.+2      	; 0x717c <main+0x98>
    717a:	90 c0       	rjmp	.+288    	; 0x729c <main+0x1b8>
    717c:	38 ec       	ldi	r19, 0xC8	; 200
            }

            // Run main application
            case COMMAND_GO_TO_APPLICATION:
            {
                USART_transmit_string(" GO_APP=");
    717e:	f3 12       	cpse	r15, r19
    7180:	f0 cf       	rjmp	.-32     	; 0x7162 <main+0x7e>
    7182:	8e e2       	ldi	r24, 0x2E	; 46

                Uart_Transmit(0x55);
    7184:	91 e0       	ldi	r25, 0x01	; 1
    7186:	a1 df       	rcall	.-190    	; 0x70ca <USART_transmit_string>
                Uart_Transmit(RESPONSE_GOING_TO_APP);
    7188:	85 e5       	ldi	r24, 0x55	; 85
    718a:	98 df       	rcall	.-208    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(RESPONSE_OK);
    718c:	81 e0       	ldi	r24, 0x01	; 1
    718e:	96 df       	rcall	.-212    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(0xAA);
    7190:	80 e0       	ldi	r24, 0x00	; 0
    7192:	94 df       	rcall	.-216    	; 0x70bc <Uart_Transmit>
    7194:	8a ea       	ldi	r24, 0xAA	; 170

                asm("jmp 0");
    7196:	92 df       	rcall	.-220    	; 0x70bc <Uart_Transmit>
                // Uart_Transmit(boot_signature_byte_get(0x01)); // RC calibration value
                // Uart_Transmit(boot_signature_byte_get(0x02)); // Temperature sensor offset
                // Uart_Transmit(boot_signature_byte_get(0x03)); // Temperature sensor gain

                Uart_Transmit(RESPONSE_OK);
                Uart_Transmit(0xAA);
    7198:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
            switch (rx_buffer[REQUEST_INDEX_COMMAND]) // Command
            {

            case COMMAND_READ_FLASH_PAGE:
            {
                USART_transmit_string(" FlR=start");
    719c:	85 e0       	ldi	r24, 0x05	; 5
    719e:	8e df       	rcall	.-228    	; 0x70bc <Uart_Transmit>

                // Parse CRC16
                uint16_t crc16;
                crc16 = rx_buffer[REQUEST_INDEX_ARGUMENT_4] << 8;
                crc16 |= rx_buffer[REQUEST_INDEX_ARGUMENT_5];
                Uart_Transmit(crc16 >> 8);
    71a0:	c1 cf       	rjmp	.-126    	; 0x7124 <main+0x40>
    71a2:	8a e0       	ldi	r24, 0x0A	; 10
    71a4:	91 e0       	ldi	r25, 0x01	; 1
                Uart_Transmit(crc16);
    71a6:	91 df       	rcall	.-222    	; 0x70ca <USART_transmit_string>
    71a8:	88 2d       	mov	r24, r8
    71aa:	88 df       	rcall	.-240    	; 0x70bc <Uart_Transmit>

                // Parse page
                page = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    71ac:	8e 2d       	mov	r24, r14
    71ae:	86 df       	rcall	.-244    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(page >> 8);
    71b0:	1c 2d       	mov	r17, r12
    71b2:	0d 2d       	mov	r16, r13
    71b4:	8c 2d       	mov	r24, r12
                Uart_Transmit(page);
    71b6:	82 df       	rcall	.-252    	; 0x70bc <Uart_Transmit>
    71b8:	8d 2d       	mov	r24, r13
    71ba:	80 df       	rcall	.-256    	; 0x70bc <Uart_Transmit>

                Uart_Transmit(0x00);
    71bc:	80 e0       	ldi	r24, 0x00	; 0
    71be:	7e df       	rcall	.-260    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(0x00);
    71c0:	80 e0       	ldi	r24, 0x00	; 0
    71c2:	7c df       	rcall	.-264    	; 0x70bc <Uart_Transmit>
    71c4:	80 e0       	ldi	r24, 0x00	; 0
                Uart_Transmit(0x00);
    71c6:	7a df       	rcall	.-268    	; 0x70bc <Uart_Transmit>
    71c8:	f8 01       	movw	r30, r16
                Uart_Transmit(crc16 >> 8);
                Uart_Transmit(crc16);

                // Parse page
                page = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    71ca:	5f 01       	movw	r10, r30
                Uart_Transmit(0x00);
                Uart_Transmit(0x00);

                // Get page (0,128,256..)
                uint16_t got_address = page;
                while (page < (got_address + SPM_PAGESIZE))
    71cc:	80 e8       	ldi	r24, 0x80	; 128
    71ce:	a8 0e       	add	r10, r24
    71d0:	b1 1c       	adc	r11, r1
    71d2:	ea 15       	cp	r30, r10
    71d4:	fb 05       	cpc	r31, r11
                // Uart_Transmit(RESPONSE_VALIDATION_FAILED);
                // Uart_Transmit(0xAA);
                // continue;


                USART_transmit_string(" Flr=ok");
    71d6:	18 f0       	brcs	.+6      	; 0x71de <main+0xfa>
    71d8:	85 e1       	ldi	r24, 0x15	; 21

                // Get page (0,128,256..)
                uint16_t got_address = page;
                while (page < (got_address + SPM_PAGESIZE))
                {
                    Uart_Transmit(pgm_read_byte(page++));
    71da:	91 e0       	ldi	r25, 0x01	; 1
    71dc:	a2 cf       	rjmp	.-188    	; 0x7122 <main+0x3e>
    71de:	3f 01       	movw	r6, r30
    71e0:	2f ef       	ldi	r18, 0xFF	; 255
    71e2:	62 1a       	sub	r6, r18
    71e4:	72 0a       	sbc	r7, r18
    71e6:	84 91       	lpm	r24, Z
    71e8:	69 df       	rcall	.-302    	; 0x70bc <Uart_Transmit>
    71ea:	f3 01       	movw	r30, r6
            }

            // Get CRC16, Uart_Transmit, data and write it to flash if it's valid
            case COMMAND_WRITE_FLASH_PAGE:
            {
                USART_transmit_string(" Fl=start");
    71ec:	f2 cf       	rjmp	.-28     	; 0x71d2 <main+0xee>
    71ee:	8d e1       	ldi	r24, 0x1D	; 29
    71f0:	91 e0       	ldi	r25, 0x01	; 1
    71f2:	6b df       	rcall	.-298    	; 0x70ca <USART_transmit_string>

                // Parse CRC16
                uint16_t crc16;
                crc16 = rx_buffer[REQUEST_INDEX_ARGUMENT_4] << 8;
                crc16 |= rx_buffer[REQUEST_INDEX_ARGUMENT_5];
                Uart_Transmit(crc16 >> 8);
    71f4:	88 2d       	mov	r24, r8
    71f6:	62 df       	rcall	.-316    	; 0x70bc <Uart_Transmit>
    71f8:	8e 2d       	mov	r24, r14
                Uart_Transmit(crc16);
    71fa:	60 df       	rcall	.-320    	; 0x70bc <Uart_Transmit>
    71fc:	1c 2d       	mov	r17, r12
    71fe:	0d 2d       	mov	r16, r13

                // Parse page
                page = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    7200:	8c 2d       	mov	r24, r12
    7202:	5c df       	rcall	.-328    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(page >> 8);
    7204:	8d 2d       	mov	r24, r13
    7206:	5a df       	rcall	.-332    	; 0x70bc <Uart_Transmit>
    7208:	52 01       	movw	r10, r4
                Uart_Transmit(page);
    720a:	51 df       	rcall	.-350    	; 0x70ae <Uart_Receive>
    720c:	f5 01       	movw	r30, r10
    720e:	81 93       	st	Z+, r24
    7210:	5f 01       	movw	r10, r30

                // Get page (0,128,256..)
                for (uint16_t i = 0; i < SPM_PAGESIZE; i++)
                {
                    rx_data[i] = Uart_Receive();
    7212:	e2 15       	cp	r30, r2
    7214:	f3 05       	cpc	r31, r3
    7216:	c9 f7       	brne	.-14     	; 0x720a <main+0x126>
    7218:	23 e0       	ldi	r18, 0x03	; 3
    721a:	f8 01       	movw	r30, r16
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
                Uart_Transmit(page >> 8);
                Uart_Transmit(page);

                // Get page (0,128,256..)
                for (uint16_t i = 0; i < SPM_PAGESIZE; i++)
    721c:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7220:	e8 95       	spm
                // Uart_Transmit(0xAA);
                // continue;

                // Write data to flash
                // Do erase before programming
                boot_page_erase(page);
    7222:	07 b6       	in	r0, 0x37	; 55
    7224:	00 fc       	sbrc	r0, 0
    7226:	fd cf       	rjmp	.-6      	; 0x7222 <main+0x13e>
    7228:	d2 01       	movw	r26, r4
    722a:	21 e0       	ldi	r18, 0x01	; 1
                boot_spm_busy_wait(); // Wait until the memory is written.
    722c:	a8 01       	movw	r20, r16
    722e:	44 19       	sub	r20, r4
    7230:	55 09       	sbc	r21, r5
    7232:	8c 91       	ld	r24, X

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
                {
                    uint16_t w = rx_data[i];
                    w |= rx_data[i + 1] << 8;
                    boot_page_fill(page + i, w);
    7234:	fa 01       	movw	r30, r20
    7236:	ea 0f       	add	r30, r26
    7238:	fb 1f       	adc	r31, r27
    723a:	11 96       	adiw	r26, 0x01	; 1
                boot_page_erase(page);
                boot_spm_busy_wait(); // Wait until the memory is written.

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
                {
                    uint16_t w = rx_data[i];
    723c:	9c 91       	ld	r25, X
                    w |= rx_data[i + 1] << 8;
                    boot_page_fill(page + i, w);
    723e:	11 97       	sbiw	r26, 0x01	; 1
    7240:	0c 01       	movw	r0, r24
                boot_spm_busy_wait(); // Wait until the memory is written.

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
                {
                    uint16_t w = rx_data[i];
                    w |= rx_data[i + 1] << 8;
    7242:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
                    boot_page_fill(page + i, w);
    7246:	e8 95       	spm
    7248:	11 24       	eor	r1, r1
    724a:	12 96       	adiw	r26, 0x02	; 2
    724c:	aa 15       	cp	r26, r10
    724e:	bb 05       	cpc	r27, r11
    7250:	81 f7       	brne	.-32     	; 0x7232 <main+0x14e>
                // Write data to flash
                // Do erase before programming
                boot_page_erase(page);
                boot_spm_busy_wait(); // Wait until the memory is written.

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
    7252:	85 e0       	ldi	r24, 0x05	; 5
    7254:	f8 01       	movw	r30, r16
                    uint16_t w = rx_data[i];
                    w |= rx_data[i + 1] << 8;
                    boot_page_fill(page + i, w);
                }

                boot_page_write(page); // Store buffer in flash page.
    7256:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    725a:	e8 95       	spm
                boot_spm_busy_wait();  // Wait until the memory is written.
    725c:	07 b6       	in	r0, 0x37	; 55
    725e:	00 fc       	sbrc	r0, 0
    7260:	fd cf       	rjmp	.-6      	; 0x725c <main+0x178>
                boot_rww_enable();
    7262:	f1 e1       	ldi	r31, 0x11	; 17
    7264:	f0 93 57 00 	sts	0x0057, r31	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>

                // Uart_Transmit(RESPONSE_FLASH_WRITTEN);
                // Uart_Transmit(RESPONSE_FLASH_WRITTEN);
                // Uart_Transmit(RESPONSE_FLASH_WRITTEN);

                USART_transmit_string(" Fl=ok");
    7268:	e8 95       	spm
    726a:	87 e2       	ldi	r24, 0x27	; 39
            case COMMAND_READ_FLASH_PAGE_SIZE:
            {
                // USART_transmit_string(" R_PG_SZ=");

                // Send pagesize to master [Startbyte MSB LSB Endbyte]
                Uart_Transmit(0x55);
    726c:	91 e0       	ldi	r25, 0x01	; 1
    726e:	59 cf       	rjmp	.-334    	; 0x7122 <main+0x3e>
                Uart_Transmit(SPM_PAGESIZE >> 8);
    7270:	85 e5       	ldi	r24, 0x55	; 85
    7272:	24 df       	rcall	.-440    	; 0x70bc <Uart_Transmit>
    7274:	80 e0       	ldi	r24, 0x00	; 0
                Uart_Transmit(SPM_PAGESIZE);
    7276:	22 df       	rcall	.-444    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(boot_signature_byte_get(0x04)); // Device signature 3
                // Uart_Transmit(boot_signature_byte_get(0x01)); // RC calibration value
                // Uart_Transmit(boot_signature_byte_get(0x02)); // Temperature sensor offset
                // Uart_Transmit(boot_signature_byte_get(0x03)); // Temperature sensor gain

                Uart_Transmit(RESPONSE_OK);
    7278:	80 e8       	ldi	r24, 0x80	; 128
                Uart_Transmit(0xAA);
    727a:	20 df       	rcall	.-448    	; 0x70bc <Uart_Transmit>
    727c:	8a ea       	ldi	r24, 0xAA	; 170

            case COMMAND_WRITE_EEPROM_BYTE:
            {
                uint16_t address;
                address = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                address |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    727e:	8f cf       	rjmp	.-226    	; 0x719e <main+0xba>
    7280:	9c 2d       	mov	r25, r12
                eeprom_busy_wait();
    7282:	8d 2d       	mov	r24, r13
                eeprom_write_byte(address, rx_buffer[REQUEST_INDEX_ARGUMENT_5]);
    7284:	f9 99       	sbic	0x1f, 1	; 31
    7286:	fe cf       	rjmp	.-4      	; 0x7284 <main+0x1a0>
    7288:	6e 2d       	mov	r22, r14
                eeprom_busy_wait();
    728a:	30 d0       	rcall	.+96     	; 0x72ec <eeprom_write_byte>
    728c:	f9 99       	sbic	0x1f, 1	; 31

                Uart_Transmit(0x55);
    728e:	fe cf       	rjmp	.-4      	; 0x728c <main+0x1a8>
    7290:	85 e5       	ldi	r24, 0x55	; 85
    7292:	14 df       	rcall	.-472    	; 0x70bc <Uart_Transmit>
                Uart_Transmit(rx_buffer[REQUEST_INDEX_ARGUMENT_5]);
    7294:	8e 2d       	mov	r24, r14
            case COMMAND_READ_DEVICE_SIGNATURE:
            {
                Uart_Transmit(0x55);
                Uart_Transmit(boot_signature_byte_get(0x00)); // Device signature 1
                Uart_Transmit(boot_signature_byte_get(0x02)); // Device signature 2
                Uart_Transmit(boot_signature_byte_get(0x04)); // Device signature 3
    7296:	12 df       	rcall	.-476    	; 0x70bc <Uart_Transmit>
    7298:	80 e0       	ldi	r24, 0x00	; 0
                // Uart_Transmit(boot_signature_byte_get(0x01)); // RC calibration value
                // Uart_Transmit(boot_signature_byte_get(0x02)); // Temperature sensor offset
                // Uart_Transmit(boot_signature_byte_get(0x03)); // Temperature sensor gain

                Uart_Transmit(RESPONSE_OK);
    729a:	ef cf       	rjmp	.-34     	; 0x727a <main+0x196>
    729c:	9c 2d       	mov	r25, r12

            case COMMAND_READ_EEPROM_BYTE:
            {
                uint16_t address;
                address = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                address |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    729e:	8d 2d       	mov	r24, r13
    72a0:	f9 99       	sbic	0x1f, 1	; 31

                eeprom_busy_wait();
    72a2:	fe cf       	rjmp	.-4      	; 0x72a0 <main+0x1bc>
    72a4:	1b d0       	rcall	.+54     	; 0x72dc <eeprom_read_byte>
                uint8_t r = eeprom_read_byte(address);
    72a6:	18 2f       	mov	r17, r24
    72a8:	85 e5       	ldi	r24, 0x55	; 85
    72aa:	08 df       	rcall	.-496    	; 0x70bc <Uart_Transmit>

                Uart_Transmit(0x55);
    72ac:	81 2f       	mov	r24, r17
    72ae:	f3 cf       	rjmp	.-26     	; 0x7296 <main+0x1b2>
    72b0:	85 e5       	ldi	r24, 0x55	; 85
                Uart_Transmit(r);
    72b2:	04 df       	rcall	.-504    	; 0x70bc <Uart_Transmit>
    72b4:	f0 e0       	ldi	r31, 0x00	; 0
                break;
            }

            case COMMAND_READ_DEVICE_SIGNATURE:
            {
                Uart_Transmit(0x55);
    72b6:	e0 e0       	ldi	r30, 0x00	; 0
    72b8:	90 92 57 00 	sts	0x0057, r9	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
                Uart_Transmit(boot_signature_byte_get(0x00)); // Device signature 1
    72bc:	84 91       	lpm	r24, Z
    72be:	fe de       	rcall	.-516    	; 0x70bc <Uart_Transmit>
    72c0:	e2 e0       	ldi	r30, 0x02	; 2
    72c2:	f0 e0       	ldi	r31, 0x00	; 0
    72c4:	90 92 57 00 	sts	0x0057, r9	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    72c8:	84 91       	lpm	r24, Z
                Uart_Transmit(boot_signature_byte_get(0x02)); // Device signature 2
    72ca:	f8 de       	rcall	.-528    	; 0x70bc <Uart_Transmit>
    72cc:	e4 e0       	ldi	r30, 0x04	; 4
    72ce:	f0 e0       	ldi	r31, 0x00	; 0
    72d0:	90 92 57 00 	sts	0x0057, r9	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    72d4:	84 91       	lpm	r24, Z
    72d6:	df cf       	rjmp	.-66     	; 0x7296 <main+0x1b2>

000072d8 <exit>:
                Uart_Transmit(boot_signature_byte_get(0x04)); // Device signature 3
    72d8:	f8 94       	cli
    72da:	16 c0       	rjmp	.+44     	; 0x7308 <_exit>

000072dc <eeprom_read_byte>:
    72dc:	f9 99       	sbic	0x1f, 1	; 31
    72de:	fe cf       	rjmp	.-4      	; 0x72dc <eeprom_read_byte>
    72e0:	92 bd       	out	0x22, r25	; 34
    72e2:	81 bd       	out	0x21, r24	; 33
    72e4:	f8 9a       	sbi	0x1f, 0	; 31
    72e6:	99 27       	eor	r25, r25
    72e8:	80 b5       	in	r24, 0x20	; 32
    72ea:	08 95       	ret

000072ec <eeprom_write_byte>:
    72ec:	26 2f       	mov	r18, r22

000072ee <eeprom_write_r18>:
    72ee:	f9 99       	sbic	0x1f, 1	; 31
    72f0:	fe cf       	rjmp	.-4      	; 0x72ee <eeprom_write_r18>
    72f2:	1f ba       	out	0x1f, r1	; 31
    72f4:	92 bd       	out	0x22, r25	; 34
    72f6:	81 bd       	out	0x21, r24	; 33
    72f8:	20 bd       	out	0x20, r18	; 32
    72fa:	0f b6       	in	r0, 0x3f	; 63
    72fc:	f8 94       	cli
    72fe:	fa 9a       	sbi	0x1f, 2	; 31
    7300:	f9 9a       	sbi	0x1f, 1	; 31
    7302:	0f be       	out	0x3f, r0	; 63
    7304:	01 96       	adiw	r24, 0x01	; 1
    7306:	08 95       	ret

00007308 <_exit>:
    7308:	f8 94       	cli

0000730a <__stop_program>:
    730a:	ff cf       	rjmp	.-2      	; 0x730a <__stop_program>
