
bootloader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000200  00800100  00007372  000003e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000372  00007000  00007000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000011  00000000  00000000  000005e6  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000005f8  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000068  00000000  00000000  00000638  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000f03  00000000  00000000  000006a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000836  00000000  00000000  000015a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000004c7  00000000  00000000  00001dd9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000084  00000000  00000000  000022a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000069b  00000000  00000000  00002324  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000004a2  00000000  00000000  000029bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000068  00000000  00000000  00002e61  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	33 c0       	rjmp	.+102    	; 0x7068 <__ctors_end>
    7002:	00 00       	nop
    7004:	44 c0       	rjmp	.+136    	; 0x708e <__bad_interrupt>
    7006:	00 00       	nop
    7008:	42 c0       	rjmp	.+132    	; 0x708e <__bad_interrupt>
    700a:	00 00       	nop
    700c:	40 c0       	rjmp	.+128    	; 0x708e <__bad_interrupt>
    700e:	00 00       	nop
    7010:	3e c0       	rjmp	.+124    	; 0x708e <__bad_interrupt>
    7012:	00 00       	nop
    7014:	3c c0       	rjmp	.+120    	; 0x708e <__bad_interrupt>
    7016:	00 00       	nop
    7018:	3a c0       	rjmp	.+116    	; 0x708e <__bad_interrupt>
    701a:	00 00       	nop
    701c:	38 c0       	rjmp	.+112    	; 0x708e <__bad_interrupt>
    701e:	00 00       	nop
    7020:	36 c0       	rjmp	.+108    	; 0x708e <__bad_interrupt>
    7022:	00 00       	nop
    7024:	34 c0       	rjmp	.+104    	; 0x708e <__bad_interrupt>
    7026:	00 00       	nop
    7028:	32 c0       	rjmp	.+100    	; 0x708e <__bad_interrupt>
    702a:	00 00       	nop
    702c:	30 c0       	rjmp	.+96     	; 0x708e <__bad_interrupt>
    702e:	00 00       	nop
    7030:	2e c0       	rjmp	.+92     	; 0x708e <__bad_interrupt>
    7032:	00 00       	nop
    7034:	2c c0       	rjmp	.+88     	; 0x708e <__bad_interrupt>
    7036:	00 00       	nop
    7038:	2a c0       	rjmp	.+84     	; 0x708e <__bad_interrupt>
    703a:	00 00       	nop
    703c:	28 c0       	rjmp	.+80     	; 0x708e <__bad_interrupt>
    703e:	00 00       	nop
    7040:	26 c0       	rjmp	.+76     	; 0x708e <__bad_interrupt>
    7042:	00 00       	nop
    7044:	24 c0       	rjmp	.+72     	; 0x708e <__bad_interrupt>
    7046:	00 00       	nop
    7048:	22 c0       	rjmp	.+68     	; 0x708e <__bad_interrupt>
    704a:	00 00       	nop
    704c:	20 c0       	rjmp	.+64     	; 0x708e <__bad_interrupt>
    704e:	00 00       	nop
    7050:	1e c0       	rjmp	.+60     	; 0x708e <__bad_interrupt>
    7052:	00 00       	nop
    7054:	1c c0       	rjmp	.+56     	; 0x708e <__bad_interrupt>
    7056:	00 00       	nop
    7058:	1a c0       	rjmp	.+52     	; 0x708e <__bad_interrupt>
    705a:	00 00       	nop
    705c:	18 c0       	rjmp	.+48     	; 0x708e <__bad_interrupt>
    705e:	00 00       	nop
    7060:	16 c0       	rjmp	.+44     	; 0x708e <__bad_interrupt>
    7062:	00 00       	nop
    7064:	14 c0       	rjmp	.+40     	; 0x708e <__bad_interrupt>
	...

00007068 <__ctors_end>:
    7068:	11 24       	eor	r1, r1
    706a:	1f be       	out	0x3f, r1	; 63
    706c:	cf ef       	ldi	r28, 0xFF	; 255
    706e:	d8 e0       	ldi	r29, 0x08	; 8
    7070:	de bf       	out	0x3e, r29	; 62
    7072:	cd bf       	out	0x3d, r28	; 61

00007074 <__do_copy_data>:
    7074:	13 e0       	ldi	r17, 0x03	; 3
    7076:	a0 e0       	ldi	r26, 0x00	; 0
    7078:	b1 e0       	ldi	r27, 0x01	; 1
    707a:	e2 e7       	ldi	r30, 0x72	; 114
    707c:	f3 e7       	ldi	r31, 0x73	; 115
    707e:	02 c0       	rjmp	.+4      	; 0x7084 <__do_copy_data+0x10>
    7080:	05 90       	lpm	r0, Z+
    7082:	0d 92       	st	X+, r0
    7084:	a0 30       	cpi	r26, 0x00	; 0
    7086:	b1 07       	cpc	r27, r17
    7088:	d9 f7       	brne	.-10     	; 0x7080 <__do_copy_data+0xc>
    708a:	35 d0       	rcall	.+106    	; 0x70f6 <main>
    708c:	58 c1       	rjmp	.+688    	; 0x733e <exit>

0000708e <__bad_interrupt>:
    708e:	b8 cf       	rjmp	.-144    	; 0x7000 <__vectors>

00007090 <Uart_Receive>:
}

static uint8_t Uart_Receive(void)
{
    /* Wait for data to be received */
    while (!(UCSR0A & (1 << RXC0)))
    7090:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    7094:	87 ff       	sbrs	r24, 7
    7096:	fc cf       	rjmp	.-8      	; 0x7090 <Uart_Receive>
        ;
    /* Get and return received data from buffer */
    return UDR0;
    7098:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
}
    709c:	08 95       	ret

0000709e <Uart_Transmit>:
static void Uart_Transmit(unsigned char data)
{
    // Set DE/RI pin

    /* Wait for empty transmit buffer */
    while (!(UCSR0A & (1 << UDRE0)))
    709e:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    70a2:	95 ff       	sbrs	r25, 5
    70a4:	fc cf       	rjmp	.-8      	; 0x709e <Uart_Transmit>
        ;
    UDR0 = data;
    70a6:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>

    // Clear DE/RI pin
}
    70aa:	08 95       	ret

000070ac <Send_Response>:
    while (*s > 0)
        Uart_Transmit(*s++);
}

static void Send_Response(uint8_t response, uint8_t resp_val)
{
    70ac:	cf 93       	push	r28
    70ae:	df 93       	push	r29
    70b0:	c8 2f       	mov	r28, r24
    70b2:	d6 2f       	mov	r29, r22
    Uart_Transmit(START_BYTE); // Send start byte
    70b4:	85 e5       	ldi	r24, 0x55	; 85
    70b6:	f3 df       	rcall	.-26     	; 0x709e <Uart_Transmit>
    Uart_Transmit(resp_val);   // Send send response's value
    70b8:	8d 2f       	mov	r24, r29
    70ba:	f1 df       	rcall	.-30     	; 0x709e <Uart_Transmit>
    Uart_Transmit(response);   // Send response
    70bc:	8c 2f       	mov	r24, r28
    70be:	ef df       	rcall	.-34     	; 0x709e <Uart_Transmit>
    70c0:	8a ea       	ldi	r24, 0xAA	; 170
    Uart_Transmit(STOP_BYTE);  // Send Stop byte
}
    70c2:	df 91       	pop	r29
    70c4:	cf 91       	pop	r28
static void Send_Response(uint8_t response, uint8_t resp_val)
{
    Uart_Transmit(START_BYTE); // Send start byte
    Uart_Transmit(resp_val);   // Send send response's value
    Uart_Transmit(response);   // Send response
    Uart_Transmit(STOP_BYTE);  // Send Stop byte
    70c6:	eb cf       	rjmp	.-42     	; 0x709e <Uart_Transmit>

000070c8 <CRC16>:
    70c8:	dc 01       	movw	r26, r24
#include "config.h"



uint16_t CRC16(const uint8_t *nData, uint16_t wLength)
{
    70ca:	68 0f       	add	r22, r24
    70cc:	79 1f       	adc	r23, r25
    70ce:	8f ef       	ldi	r24, 0xFF	; 255
            0X4E00, 0X8EC1, 0X8F81, 0X4F40, 0X8D01, 0X4DC0, 0X4C80, 0X8C41,
            0X4400, 0X84C1, 0X8581, 0X4540, 0X8701, 0X47C0, 0X4680, 0X8641,
            0X8201, 0X42C0, 0X4380, 0X8341, 0X4100, 0X81C1, 0X8081, 0X4040};

    uint8_t nTemp;
    uint16_t wCRCWord = 0xFFFF;
    70d0:	9f ef       	ldi	r25, 0xFF	; 255
    70d2:	a6 17       	cp	r26, r22

    while (wLength--)
    70d4:	b7 07       	cpc	r27, r23
    70d6:	09 f4       	brne	.+2      	; 0x70da <CRC16+0x12>
    70d8:	08 95       	ret
        nTemp = *nData++ ^ wCRCWord;
        wCRCWord >>= 8;
        wCRCWord ^= wCRCTable[nTemp];
    }
    return wCRCWord;
}
    70da:	ed 91       	ld	r30, X+
    uint8_t nTemp;
    uint16_t wCRCWord = 0xFFFF;

    while (wLength--)
    {
        nTemp = *nData++ ^ wCRCWord;
    70dc:	29 2f       	mov	r18, r25
        wCRCWord >>= 8;
    70de:	33 27       	eor	r19, r19
    70e0:	e8 27       	eor	r30, r24
    uint8_t nTemp;
    uint16_t wCRCWord = 0xFFFF;

    while (wLength--)
    {
        nTemp = *nData++ ^ wCRCWord;
    70e2:	f0 e0       	ldi	r31, 0x00	; 0
        wCRCWord >>= 8;
        wCRCWord ^= wCRCTable[nTemp];
    70e4:	ee 0f       	add	r30, r30
    70e6:	ff 1f       	adc	r31, r31
    70e8:	e0 50       	subi	r30, 0x00	; 0
    70ea:	ff 4f       	sbci	r31, 0xFF	; 255
    70ec:	80 81       	ld	r24, Z
    70ee:	91 81       	ldd	r25, Z+1	; 0x01
    70f0:	82 27       	eor	r24, r18
    70f2:	93 27       	eor	r25, r19
    70f4:	ee cf       	rjmp	.-36     	; 0x70d2 <CRC16+0xa>

000070f6 <main>:
    70f6:	cf 93       	push	r28
    RESPONSE_INDEX_ARGUMENT_1,
    RESPONSE_INDEX_ARGUMENT_0,
} Response_index;

main()
{
    70f8:	df 93       	push	r29
    70fa:	cd b7       	in	r28, 0x3d	; 61
    70fc:	de b7       	in	r29, 0x3e	; 62
    70fe:	c5 58       	subi	r28, 0x85	; 133
    7100:	d1 09       	sbc	r29, r1
    7102:	0f b6       	in	r0, 0x3f	; 63
    7104:	f8 94       	cli
    7106:	de bf       	out	0x3e, r29	; 62
    7108:	0f be       	out	0x3f, r0	; 63
    710a:	cd bf       	out	0x3d, r28	; 61
    uint8_t sreg = SREG;
    710c:	4f b6       	in	r4, 0x3f	; 63
    uint8_t rx_buffer[3];
    uint8_t rx_data[SPM_PAGESIZE];

    State state = STATE_START;

    cli();
    710e:	f8 94       	cli
static void Init_Uart()
{

#define BAUD 9600
#include <util/setbaud.h>
    UBRR0H = UBRRH_VALUE;
    7110:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
    UBRR0L = UBRRL_VALUE;
    7114:	87 e6       	ldi	r24, 0x67	; 103
    7116:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
#if USE_2X
    UCSR0A |= (1 << U2X0);
#else
    UCSR0A &= ~(1 << U2X0);
    711a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    711e:	8d 7f       	andi	r24, 0xFD	; 253
    7120:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
#endif

    UCSR0A |= (1 << UDRE0); // Clear transmit buffer
    7124:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    7128:	80 62       	ori	r24, 0x20	; 32
    712a:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>

    UCSR0B = (1 << TXEN0);  // Enable transmitter
    712e:	88 e0       	ldi	r24, 0x08	; 8
    7130:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    UCSR0B |= (1 << RXEN0); // Enable receiver
    7134:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    7138:	80 61       	ori	r24, 0x10	; 16
    713a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>

    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // Set frame: 8data, 1 stop
    713e:	86 e0       	ldi	r24, 0x06	; 6
    7140:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
    Uart_Transmit(STOP_BYTE);  // Send Stop byte
}

static void Send_Response_2(uint8_t response, uint8_t arg3, uint8_t arg2, uint8_t arg1, uint8_t arg0)
{
    Uart_Transmit(START_BYTE); // Send start byte
    7144:	85 e5       	ldi	r24, 0x55	; 85
    7146:	ab df       	rcall	.-170    	; 0x709e <Uart_Transmit>
    Uart_Transmit(response);   // Send response
    7148:	80 e0       	ldi	r24, 0x00	; 0
    714a:	a9 df       	rcall	.-174    	; 0x709e <Uart_Transmit>
    Uart_Transmit(arg3);       // Send argument
    714c:	81 e0       	ldi	r24, 0x01	; 1
    714e:	a7 df       	rcall	.-178    	; 0x709e <Uart_Transmit>
    Uart_Transmit(arg2);       // Send argument
    7150:	82 e0       	ldi	r24, 0x02	; 2
    7152:	a5 df       	rcall	.-182    	; 0x709e <Uart_Transmit>
    Uart_Transmit(arg1);       // Send argument
    7154:	83 e0       	ldi	r24, 0x03	; 3
    7156:	a3 df       	rcall	.-186    	; 0x709e <Uart_Transmit>
    Uart_Transmit(arg0);       // Send argument
    7158:	84 e0       	ldi	r24, 0x04	; 4
    715a:	a1 df       	rcall	.-190    	; 0x709e <Uart_Transmit>
    715c:	8a ea       	ldi	r24, 0xAA	; 170
    Uart_Transmit(STOP_BYTE);  // Send Stop byte
    715e:	9f df       	rcall	.-194    	; 0x709e <Uart_Transmit>
    7160:	90 e0       	ldi	r25, 0x00	; 0
    7162:	80 e0       	ldi	r24, 0x00	; 0
    uint16_t page = 0;
    uint8_t checksum = 0;
    uint8_t rx_buffer[3];
    uint8_t rx_data[SPM_PAGESIZE];

    State state = STATE_START;
    7164:	8e 01       	movw	r16, r28
    7166:	0f 57       	subi	r16, 0x7F	; 127
            break;
        }

        case STATE_PARSE_REQUEST:
        {
            switch (rx_buffer[REQUEST_INDEX_COMMAND]) // Command
    7168:	1f 4f       	sbci	r17, 0xFF	; 255
    716a:	21 e2       	ldi	r18, 0x21	; 33
    716c:	52 2e       	mov	r5, r18
            }

            case COMMAND_READ_DEVICE_SIGNATURE:
            {
                Uart_Transmit(START_BYTE);
                Uart_Transmit(boot_signature_byte_get(0x00)); // Device signature 1
    716e:	31 2c       	mov	r3, r1
    7170:	21 2c       	mov	r2, r1
    7172:	9e 01       	movw	r18, r28
    7174:	2f 5f       	subi	r18, 0xFF	; 255
                    rx_buffer[i] = pgm_read_byte(addr);
                    Uart_Transmit(rx_buffer[i]);
                    i++;
                }

                uint16_t crc16_calc = CRC16(&rx_data, SPM_PAGESIZE);
    7176:	3f 4f       	sbci	r19, 0xFF	; 255
    7178:	79 01       	movw	r14, r18
    717a:	81 30       	cpi	r24, 0x01	; 1
    717c:	91 05       	cpc	r25, r1

    Send_Response_2(0,1,2,3,4);

    while (1)
    {
        switch (state)
    717e:	29 f0       	breq	.+10     	; 0x718a <main+0x94>
    7180:	02 97       	sbiw	r24, 0x02	; 2
    7182:	a9 f0       	breq	.+42     	; 0x71ae <main+0xb8>
        {

        case STATE_START:
        {
            Send_Response(RESPONSE_BOOTLOADER_STARTED, 0);
    7184:	60 e0       	ldi	r22, 0x00	; 0
    7186:	82 e0       	ldi	r24, 0x02	; 2
    7188:	91 df       	rcall	.-222    	; 0x70ac <Send_Response>
            break;
        }

        case STATE_POOL_REQUEST:
        {
            if (Uart_Receive() == START_BYTE) // Start byte
    718a:	82 df       	rcall	.-252    	; 0x7090 <Uart_Receive>
    718c:	85 35       	cpi	r24, 0x55	; 85
            {
                rx_buffer[REQUEST_INDEX_COMMAND] = Uart_Receive();    // Command
    718e:	11 f5       	brne	.+68     	; 0x71d4 <main+0xde>
    7190:	7f df       	rcall	.-258    	; 0x7090 <Uart_Receive>
    7192:	f8 01       	movw	r30, r16
                rx_buffer[REQUEST_INDEX_ARGUMENT_0] = Uart_Receive(); // Argument_0 - PAGE  3
    7194:	80 83       	st	Z, r24
    7196:	7c df       	rcall	.-264    	; 0x7090 <Uart_Receive>
                rx_buffer[REQUEST_INDEX_ARGUMENT_1] = Uart_Receive(); // Argument_1 - PAGE  2
    7198:	7b df       	rcall	.-266    	; 0x7090 <Uart_Receive>
    719a:	7a df       	rcall	.-268    	; 0x7090 <Uart_Receive>
                rx_buffer[REQUEST_INDEX_ARGUMENT_2] = Uart_Receive(); // Argument_2 - PAGE  1
    719c:	68 2e       	mov	r6, r24
    719e:	78 df       	rcall	.-272    	; 0x7090 <Uart_Receive>
    71a0:	78 2e       	mov	r7, r24
                rx_buffer[REQUEST_INDEX_ARGUMENT_3] = Uart_Receive(); // Argument_3 - PAGE  0
    71a2:	76 df       	rcall	.-276    	; 0x7090 <Uart_Receive>
    71a4:	f8 01       	movw	r30, r16
    71a6:	82 83       	std	Z+2, r24	; 0x02
                rx_buffer[REQUEST_INDEX_ARGUMENT_4] = Uart_Receive(); // Argument_4 - CRC16 1
    71a8:	73 df       	rcall	.-282    	; 0x7090 <Uart_Receive>
    71aa:	f8 01       	movw	r30, r16
    71ac:	81 83       	std	Z+1, r24	; 0x01
    71ae:	f8 01       	movw	r30, r16
                rx_buffer[REQUEST_INDEX_ARGUMENT_5] = Uart_Receive(); // Argument_5 - CRC16 0
    71b0:	80 81       	ld	r24, Z
    71b2:	86 30       	cpi	r24, 0x06	; 6
    71b4:	09 f4       	brne	.+2      	; 0x71b8 <main+0xc2>
            break;
        }

        case STATE_PARSE_REQUEST:
        {
            switch (rx_buffer[REQUEST_INDEX_COMMAND]) // Command
    71b6:	9c c0       	rjmp	.+312    	; 0x72f0 <main+0x1fa>
    71b8:	80 f4       	brcc	.+32     	; 0x71da <main+0xe4>
    71ba:	84 30       	cpi	r24, 0x04	; 4
    71bc:	e1 f0       	breq	.+56     	; 0x71f6 <main+0x100>
    71be:	08 f0       	brcs	.+2      	; 0x71c2 <main+0xcc>
    71c0:	8f c0       	rjmp	.+286    	; 0x72e0 <main+0x1ea>
    71c2:	83 30       	cpi	r24, 0x03	; 3
    71c4:	09 f4       	brne	.+2      	; 0x71c8 <main+0xd2>
    71c6:	38 c0       	rjmp	.+112    	; 0x7238 <main+0x142>
    71c8:	61 e0       	ldi	r22, 0x01	; 1
    71ca:	81 e0       	ldi	r24, 0x01	; 1
    71cc:	6f df       	rcall	.-290    	; 0x70ac <Send_Response>
    71ce:	82 e0       	ldi	r24, 0x02	; 2
                state = STATE_POOL_REQUEST;
                break;
            }

            default:
                Send_Response(RESPONSE_ERR, RESPONSE_ERR);
    71d0:	90 e0       	ldi	r25, 0x00	; 0
    71d2:	d3 cf       	rjmp	.-90     	; 0x717a <main+0x84>
    71d4:	81 e0       	ldi	r24, 0x01	; 1
                break;
    71d6:	90 e0       	ldi	r25, 0x00	; 0
    71d8:	d0 cf       	rjmp	.-96     	; 0x717a <main+0x84>
    71da:	88 30       	cpi	r24, 0x08	; 8
    71dc:	09 f4       	brne	.+2      	; 0x71e0 <main+0xea>
    71de:	9c c0       	rjmp	.+312    	; 0x7318 <main+0x222>
            break;
        }

        case STATE_PARSE_REQUEST:
        {
            switch (rx_buffer[REQUEST_INDEX_COMMAND]) // Command
    71e0:	08 f4       	brcc	.+2      	; 0x71e4 <main+0xee>
    71e2:	92 c0       	rjmp	.+292    	; 0x7308 <main+0x212>
    71e4:	88 3c       	cpi	r24, 0xC8	; 200
    71e6:	81 f7       	brne	.-32     	; 0x71c8 <main+0xd2>
    71e8:	60 e0       	ldi	r22, 0x00	; 0
    71ea:	86 e0       	ldi	r24, 0x06	; 6
    71ec:	5f df       	rcall	.-322    	; 0x70ac <Send_Response>
            }

            // Run main application
            case COMMAND_GO_TO_APPLICATION:
            {
                Send_Response(RESPONSE_GOING_TO_APP, 0);
    71ee:	4f be       	out	0x3f, r4	; 63
    71f0:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
    71f4:	ca cf       	rjmp	.-108    	; 0x718a <main+0x94>

                SREG = sreg;
    71f6:	60 e0       	ldi	r22, 0x00	; 0

                asm("jmp 0");
    71f8:	85 e0       	ldi	r24, 0x05	; 5
    71fa:	58 df       	rcall	.-336    	; 0x70ac <Send_Response>
            switch (rx_buffer[REQUEST_INDEX_COMMAND]) // Command
            {

            case COMMAND_READ_FLASH_PAGE:
            {
                Send_Response(RESPONSE_FLASH_READ, 0);
    71fc:	58 01       	movw	r10, r16
    71fe:	d6 2c       	mov	r13, r6
    7200:	c7 2c       	mov	r12, r7
                // Parse page
                page = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];

                uint16_t i = 0;
                for (uint16_t addr = page; addr < (page + SPM_PAGESIZE); addr++)
    7202:	46 01       	movw	r8, r12
    7204:	f0 e8       	ldi	r31, 0x80	; 128
    7206:	8f 0e       	add	r8, r31
    7208:	91 1c       	adc	r9, r1
    720a:	c8 14       	cp	r12, r8
    720c:	d9 04       	cpc	r13, r9
    720e:	50 f0       	brcs	.+20     	; 0x7224 <main+0x12e>
    7210:	60 e8       	ldi	r22, 0x80	; 128
                    rx_buffer[i] = pgm_read_byte(addr);
                    Uart_Transmit(rx_buffer[i]);
                    i++;
                }

                uint16_t crc16_calc = CRC16(&rx_data, SPM_PAGESIZE);
    7212:	70 e0       	ldi	r23, 0x00	; 0
    7214:	c7 01       	movw	r24, r14
    7216:	58 df       	rcall	.-336    	; 0x70c8 <CRC16>
    7218:	6c 01       	movw	r12, r24
    721a:	8d 2d       	mov	r24, r13
                Uart_Transmit(crc16_calc >> 8);
    721c:	40 df       	rcall	.-384    	; 0x709e <Uart_Transmit>
    721e:	8c 2d       	mov	r24, r12
    7220:	3e df       	rcall	.-388    	; 0x709e <Uart_Transmit>
                Uart_Transmit(crc16_calc);
    7222:	b3 cf       	rjmp	.-154    	; 0x718a <main+0x94>
            {
                // Send pagesize to master [Startbyte MSB LSB Endbyte]
                Uart_Transmit(START_BYTE);
                Uart_Transmit(SPM_PAGESIZE >> 8);
                Uart_Transmit(SPM_PAGESIZE);
                Uart_Transmit(STOP_BYTE);
    7224:	f6 01       	movw	r30, r12
    7226:	84 91       	lpm	r24, Z
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];

                uint16_t i = 0;
                for (uint16_t addr = page; addr < (page + SPM_PAGESIZE); addr++)
                {
                    rx_buffer[i] = pgm_read_byte(addr);
    7228:	f5 01       	movw	r30, r10
    722a:	81 93       	st	Z+, r24
    722c:	5f 01       	movw	r10, r30
    722e:	37 df       	rcall	.-402    	; 0x709e <Uart_Transmit>
    7230:	ff ef       	ldi	r31, 0xFF	; 255
                    Uart_Transmit(rx_buffer[i]);
    7232:	cf 1a       	sub	r12, r31
    7234:	df 0a       	sbc	r13, r31
                // Parse page
                page = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];

                uint16_t i = 0;
                for (uint16_t addr = page; addr < (page + SPM_PAGESIZE); addr++)
    7236:	e9 cf       	rjmp	.-46     	; 0x720a <main+0x114>
    7238:	60 e0       	ldi	r22, 0x00	; 0
    723a:	80 e0       	ldi	r24, 0x00	; 0
            }

            // Get CRC16, Uart_Transmit, data and write it to flash if it's valid
            case COMMAND_WRITE_FLASH_PAGE:
            {
                Send_Response(RESPONSE_OK, 0);
    723c:	37 df       	rcall	.-402    	; 0x70ac <Send_Response>
    723e:	f8 01       	movw	r30, r16
    7240:	a2 80       	ldd	r10, Z+2	; 0x02
    7242:	81 81       	ldd	r24, Z+1	; 0x01

                // Parse CRC16
                uint16_t crc16_rx;
                crc16_rx = rx_buffer[REQUEST_INDEX_ARGUMENT_4] << 8;
    7244:	ba 2c       	mov	r11, r10
    7246:	a8 2e       	mov	r10, r24
                crc16_rx |= rx_buffer[REQUEST_INDEX_ARGUMENT_5];
    7248:	67 01       	movw	r12, r14
    724a:	22 df       	rcall	.-444    	; 0x7090 <Uart_Receive>
    724c:	f6 01       	movw	r30, r12
    724e:	81 93       	st	Z+, r24
                // Uart_Transmit(page);

                // Receive flash page's data through communication
                for (uint16_t i = 0; i < SPM_PAGESIZE; i++)
                {
                    rx_data[i] = Uart_Receive();
    7250:	6f 01       	movw	r12, r30
    7252:	e0 17       	cp	r30, r16
    7254:	f1 07       	cpc	r31, r17
    7256:	c9 f7       	brne	.-14     	; 0x724a <main+0x154>
    7258:	60 e8       	ldi	r22, 0x80	; 128
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
                // Uart_Transmit(page >> 8);
                // Uart_Transmit(page);

                // Receive flash page's data through communication
                for (uint16_t i = 0; i < SPM_PAGESIZE; i++)
    725a:	70 e0       	ldi	r23, 0x00	; 0
    725c:	c7 01       	movw	r24, r14
    725e:	34 df       	rcall	.-408    	; 0x70c8 <CRC16>
                {
                    rx_data[i] = Uart_Receive();
                }

                // Do data validation
                volatile uint16_t crc16_calc = CRC16(&rx_data, SPM_PAGESIZE);
    7260:	cc 57       	subi	r28, 0x7C	; 124
    7262:	df 4f       	sbci	r29, 0xFF	; 255
    7264:	99 83       	std	Y+1, r25	; 0x01
    7266:	88 83       	st	Y, r24
    7268:	c4 58       	subi	r28, 0x84	; 132
    726a:	d0 40       	sbci	r29, 0x00	; 0
    726c:	cc 57       	subi	r28, 0x7C	; 124
    726e:	df 4f       	sbci	r29, 0xFF	; 255
    7270:	88 81       	ld	r24, Y
    7272:	99 81       	ldd	r25, Y+1	; 0x01
    7274:	c4 58       	subi	r28, 0x84	; 132

                // Check if received data is valid
                if (crc16_calc != crc16_rx)
    7276:	d0 40       	sbci	r29, 0x00	; 0
    7278:	8a 15       	cp	r24, r10
    727a:	9b 05       	cpc	r25, r11
    727c:	19 f0       	breq	.+6      	; 0x7284 <main+0x18e>
    727e:	60 e0       	ldi	r22, 0x00	; 0
    7280:	83 e0       	ldi	r24, 0x03	; 3
    7282:	82 cf       	rjmp	.-252    	; 0x7188 <main+0x92>
    7284:	96 2d       	mov	r25, r6
    7286:	87 2d       	mov	r24, r7
                {
                    Send_Response(RESPONSE_VALIDATION_FAILED, 0); // Send when data is received but failed to validate
    7288:	23 e0       	ldi	r18, 0x03	; 3
    728a:	fc 01       	movw	r30, r24
    728c:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
                crc16_rx = rx_buffer[REQUEST_INDEX_ARGUMENT_4] << 8;
                crc16_rx |= rx_buffer[REQUEST_INDEX_ARGUMENT_5];

                // Parse page
                page = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                page |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    7290:	e8 95       	spm
                    state = STATE_POOL_REQUEST;
                    break;
                }

                // Write data to flash
                boot_page_erase(page); // Do erase before programming
    7292:	07 b6       	in	r0, 0x37	; 55
    7294:	00 fc       	sbrc	r0, 0
    7296:	fd cf       	rjmp	.-6      	; 0x7292 <main+0x19c>
    7298:	d7 01       	movw	r26, r14
    729a:	61 e0       	ldi	r22, 0x01	; 1
                boot_spm_busy_wait();  // Wait until the memory is written.
    729c:	ac 01       	movw	r20, r24
    729e:	4e 19       	sub	r20, r14
    72a0:	5f 09       	sbc	r21, r15
    72a2:	fa 01       	movw	r30, r20

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
                {
                    uint16_t w = (rx_data[i]) | (rx_data[i + 1] << 8);
                    boot_page_fill(page + i, w);
    72a4:	ea 0f       	add	r30, r26
    72a6:	fb 1f       	adc	r31, r27
    72a8:	11 96       	adiw	r26, 0x01	; 1
    72aa:	3c 91       	ld	r19, X
    72ac:	11 97       	sbiw	r26, 0x01	; 1
    72ae:	2c 91       	ld	r18, X
    72b0:	09 01       	movw	r0, r18
                boot_page_erase(page); // Do erase before programming
                boot_spm_busy_wait();  // Wait until the memory is written.

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
                {
                    uint16_t w = (rx_data[i]) | (rx_data[i + 1] << 8);
    72b2:	60 93 57 00 	sts	0x0057, r22	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    72b6:	e8 95       	spm
                    boot_page_fill(page + i, w);
    72b8:	11 24       	eor	r1, r1
    72ba:	12 96       	adiw	r26, 0x02	; 2
    72bc:	ca 16       	cp	r12, r26
    72be:	db 06       	cpc	r13, r27

                // Write data to flash
                boot_page_erase(page); // Do erase before programming
                boot_spm_busy_wait();  // Wait until the memory is written.

                for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
    72c0:	81 f7       	brne	.-32     	; 0x72a2 <main+0x1ac>
    72c2:	25 e0       	ldi	r18, 0x05	; 5
    72c4:	fc 01       	movw	r30, r24
                {
                    uint16_t w = (rx_data[i]) | (rx_data[i + 1] << 8);
                    boot_page_fill(page + i, w);
                }

                boot_page_write(page); // Store buffer in flash page.
    72c6:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    72ca:	e8 95       	spm
    72cc:	07 b6       	in	r0, 0x37	; 55
                boot_spm_busy_wait();  // Wait until the memory is written.
    72ce:	00 fc       	sbrc	r0, 0
    72d0:	fd cf       	rjmp	.-6      	; 0x72cc <main+0x1d6>
    72d2:	f1 e1       	ldi	r31, 0x11	; 17
                boot_rww_enable();
    72d4:	f0 93 57 00 	sts	0x0057, r31	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    72d8:	e8 95       	spm
    72da:	60 e0       	ldi	r22, 0x00	; 0

                Send_Response(RESPONSE_FLASH_WRITTEN, 0);
    72dc:	84 e0       	ldi	r24, 0x04	; 4
    72de:	54 cf       	rjmp	.-344    	; 0x7188 <main+0x92>

            // Send flash pagesize to master
            case COMMAND_READ_FLASH_PAGE_SIZE: //
            {
                // Send pagesize to master [Startbyte MSB LSB Endbyte]
                Uart_Transmit(START_BYTE);
    72e0:	85 e5       	ldi	r24, 0x55	; 85
    72e2:	dd de       	rcall	.-582    	; 0x709e <Uart_Transmit>
    72e4:	80 e0       	ldi	r24, 0x00	; 0
                Uart_Transmit(SPM_PAGESIZE >> 8);
    72e6:	db de       	rcall	.-586    	; 0x709e <Uart_Transmit>
    72e8:	80 e8       	ldi	r24, 0x80	; 128
                Uart_Transmit(SPM_PAGESIZE);
    72ea:	d9 de       	rcall	.-590    	; 0x709e <Uart_Transmit>
    72ec:	8a ea       	ldi	r24, 0xAA	; 170
                Uart_Transmit(STOP_BYTE);
    72ee:	98 cf       	rjmp	.-208    	; 0x7220 <main+0x12a>
    72f0:	96 2d       	mov	r25, r6

            case COMMAND_WRITE_EEPROM_BYTE:
            {
                uint16_t address;
                address = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                address |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    72f2:	87 2d       	mov	r24, r7
    72f4:	f9 99       	sbic	0x1f, 1	; 31
                eeprom_busy_wait();
    72f6:	fe cf       	rjmp	.-4      	; 0x72f4 <main+0x1fe>
                eeprom_write_byte(address, rx_buffer[REQUEST_INDEX_ARGUMENT_5]);
    72f8:	f8 01       	movw	r30, r16
    72fa:	61 81       	ldd	r22, Z+1	; 0x01
    72fc:	2a d0       	rcall	.+84     	; 0x7352 <eeprom_write_byte>
    72fe:	f9 99       	sbic	0x1f, 1	; 31
                eeprom_busy_wait();
    7300:	fe cf       	rjmp	.-4      	; 0x72fe <main+0x208>
    7302:	60 e0       	ldi	r22, 0x00	; 0

                Send_Response(RESPONSE_WRITING_EEPROM, 0);
    7304:	88 e0       	ldi	r24, 0x08	; 8
    7306:	40 cf       	rjmp	.-384    	; 0x7188 <main+0x92>
    7308:	96 2d       	mov	r25, r6

            case COMMAND_READ_EEPROM_BYTE:
            {
                uint16_t address;
                address = rx_buffer[REQUEST_INDEX_ARGUMENT_2] << 8;
                address |= rx_buffer[REQUEST_INDEX_ARGUMENT_3];
    730a:	87 2d       	mov	r24, r7
    730c:	f9 99       	sbic	0x1f, 1	; 31

                eeprom_busy_wait();
    730e:	fe cf       	rjmp	.-4      	; 0x730c <main+0x216>
    7310:	18 d0       	rcall	.+48     	; 0x7342 <eeprom_read_byte>
                uint8_t read = eeprom_read_byte(address);
    7312:	68 2f       	mov	r22, r24
    7314:	87 e0       	ldi	r24, 0x07	; 7
                Send_Response(RESPONSE_READING_EEPROM, read);
    7316:	38 cf       	rjmp	.-400    	; 0x7188 <main+0x92>
    7318:	85 e5       	ldi	r24, 0x55	; 85
    731a:	c1 de       	rcall	.-638    	; 0x709e <Uart_Transmit>
                break;
            }

            case COMMAND_READ_DEVICE_SIGNATURE:
            {
                Uart_Transmit(START_BYTE);
    731c:	f1 01       	movw	r30, r2
    731e:	50 92 57 00 	sts	0x0057, r5	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
                Uart_Transmit(boot_signature_byte_get(0x00)); // Device signature 1
    7322:	84 91       	lpm	r24, Z
    7324:	bc de       	rcall	.-648    	; 0x709e <Uart_Transmit>
    7326:	e2 e0       	ldi	r30, 0x02	; 2
    7328:	f0 e0       	ldi	r31, 0x00	; 0
    732a:	50 92 57 00 	sts	0x0057, r5	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
                Uart_Transmit(boot_signature_byte_get(0x02)); // Device signature 2
    732e:	84 91       	lpm	r24, Z
    7330:	b6 de       	rcall	.-660    	; 0x709e <Uart_Transmit>
    7332:	e4 e0       	ldi	r30, 0x04	; 4
    7334:	f0 e0       	ldi	r31, 0x00	; 0
    7336:	50 92 57 00 	sts	0x0057, r5	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    733a:	84 91       	lpm	r24, Z
                Uart_Transmit(boot_signature_byte_get(0x04)); // Device signature 3
    733c:	d6 cf       	rjmp	.-84     	; 0x72ea <main+0x1f4>

0000733e <exit>:
    733e:	f8 94       	cli
    7340:	16 c0       	rjmp	.+44     	; 0x736e <_exit>

00007342 <eeprom_read_byte>:
    7342:	f9 99       	sbic	0x1f, 1	; 31
    7344:	fe cf       	rjmp	.-4      	; 0x7342 <eeprom_read_byte>
    7346:	92 bd       	out	0x22, r25	; 34
    7348:	81 bd       	out	0x21, r24	; 33
    734a:	f8 9a       	sbi	0x1f, 0	; 31
    734c:	99 27       	eor	r25, r25
    734e:	80 b5       	in	r24, 0x20	; 32
    7350:	08 95       	ret

00007352 <eeprom_write_byte>:
    7352:	26 2f       	mov	r18, r22

00007354 <eeprom_write_r18>:
    7354:	f9 99       	sbic	0x1f, 1	; 31
    7356:	fe cf       	rjmp	.-4      	; 0x7354 <eeprom_write_r18>
    7358:	1f ba       	out	0x1f, r1	; 31
    735a:	92 bd       	out	0x22, r25	; 34
    735c:	81 bd       	out	0x21, r24	; 33
    735e:	20 bd       	out	0x20, r18	; 32
    7360:	0f b6       	in	r0, 0x3f	; 63
    7362:	f8 94       	cli
    7364:	fa 9a       	sbi	0x1f, 2	; 31
    7366:	f9 9a       	sbi	0x1f, 1	; 31
    7368:	0f be       	out	0x3f, r0	; 63
    736a:	01 96       	adiw	r24, 0x01	; 1
    736c:	08 95       	ret

0000736e <_exit>:
    736e:	f8 94       	cli

00007370 <__stop_program>:
    7370:	ff cf       	rjmp	.-2      	; 0x7370 <__stop_program>
